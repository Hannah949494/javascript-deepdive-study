# 스코프

스코프는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이며 중요한 개념입니다. 스코프의 이해가 부족하면 다른 개념을 이해하기 어려울 수 있어요. 그리고 면접에서 단골 질문이라서 꼭 확실히 이해하고 가야합니다.

그리고 `var` 키워드로 선언한 변수와 `let` 또는 `const` 키워드로 선언한 변수의 스코프도 다르게 동작하니 꼭 꼭 잘 알고 가셔야 합니다.

우리는 이미 스코프를 앞에서 경험한 적이 있어요. 함수의 매개변수는 함수 몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다고 했었죠? 이게 매개변수를 참조할 수 있는 유효범위, 즉 매개변수의 스코프가 함수 몸체 내부로 한정되기 때문입니다.

```js
function add(x, y) {
  console.log(x, y);
  return x + y;
}
add(2, 5);

console.log(x, y); // ReferenceError : x is not defined
```

```js
var var1 = 1;

if (true) {
  var var2 = 2;
  if (true) {
    var var3 = 3;
  }
}

function foo() {
  var var4 = 4;

  function bar() {
    var var5 = 5;
  }
}

console.log(var1); // 1
console.log(var2); // 2
console.log(var3); // 3;
console.log(var4); // ReferenceError : var4 is not defined
console.log(var5); // ReferenceError : var5 is not defined
```

변수는 자신이 선언된 위치에 의해 자신이 유효한 범위, 다른 코드가 변수 자신을 참조할 수 있는 범위가 결정됩니다. 변수 뿐만 아니라 모든 식별자가 그래요.

**모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프라 합니다. 즉, 스코프는 식별자가 유효한 범위를 말한다**.

```js
var x = "global";

function foo() {
  var x = "local";
  console.log(x);
}

foo();

console.log(x);
```

그럼 이 코드는 어떻게 작동할까요? 코드 바깥에 전역변수 `x`가 있고 `foo` 함수 내에 변수 `x`를 선언하여 `console.log`로 `x`를 확인합니다. 그 뒤에 함수를 호출한 뒤 `x`를 다시 콘솔로 확인하고 있어요. `console.log(x)`에 찍힌 두개의 값은 동일할까요?

아닙니다. `foo` 함수 내에 찍힌 `console.log(x)`의 값은 `local`, 함수 바깥쪽에서 찍은 `console.log(x)`는 `global` 입니다.

자바스크립트 엔진은 이름이 같은 두 개의 변수 중에서 어떤 변수를 참조해야 할 것인지를 결정하는데, 이걸 **식별자 결정** 이라고 하는데요, 자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조 할 것인지 결정합니다.

따라서 스코프란 자바스크립트 엔진이 **식별자를 검색할 때 사용하는 규칙** 이라고 할 수 있어요.

만약 스코프라는 개념이 없으면 같은 이름을 갖는 변수는 충돌을 일으킬테니 프로그램 전체에서하나밖에 사용할 수 없겠죠?

식별자는 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름입니다. 유일해야 하기때문에 식별자인 변수 이름은 중복될 수 없어요. 하나의 값은 유일한 식별자에 연결되어야 합니다.

예를 들자면 우리가 프로그램을 하나 크롬에서 다운받았다고 할게요, 그런데 다운로드 폴더 안에는 동일한 프로그램이 이미 존재한다고 하면, 크롬은 다운로드 할때 이름을 `(1)` 같은걸 추가해서 다운로드 하게 될거에요, 다운로드된 프로그램의 이름은 식별자이기 때문에 중복해서 사용할 수 없어요, 하지만 다른 폴더에 다운로드를 받게되면 파일 이름이 변경되지 않은 온전한 이름으로 다운로드가 되겠죠? 마찬가지로 프로그래밍 언어에서는 스코프를 통해 식별자인 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있게 만들어줘요.

### var 키워드로 선언한 변수의 중복 선언

var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용됩니다. 그래서 의도치 않게 변수값이 재할당되어 변경되는 부작용이 발생돼요, 하지만 let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않아서 var 키워드를 최근에는 사용하지 않습니다. (jquery 같은경우에선 현재도 사용되는걸 많이 보긴 했어요.)

## 스코프의 종류

코드는 전역과 지역으로 구분할 수 있는데 스코프도 전역 스코프와 지역 스코프로 구분할 수 있어요.

| 구분 |         설명          |   스코프    |   변수    |
| ---- | :-------------------: | :---------: | :-------: |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역변수  |
| 지역 |    함수 몸체 내부     | 지역 스코프 | 지역 변수 |

변수는 자신이 선언된 위치에 의해 자신의 스코프가 결정됩니다.

```js
var x = "global x";
var y = "global y";

function outer() {
  var z = `outer's local z`;

  console.log(x); // global x
  console.log(y); // global y
  console.log(z); // outer's local z

  function inner() {
    var x = `inner's local x`;

    console.log(x); // inner's local x;
    console.log(y); // global y
    console.log(z); // outer's local z
  }
  inner();
}

outer();

console.log(x); // global x;
console.log(z); //ReferenceError : z is not defined
```

위 코드를 확인해주세요. 지역스코프와 전역스코프를 설명하고 있습니다. 코드 최상단에 선언한 `x, y`는 전역스코프인 `전역 변수` 입니다. 코드 어디에서든 참조할 수 있어요. 하지만 `outer, inner` 함수 내에서 선언된 `z`와 재선언한 `x`의 같은 경우에는 지역 스코프를 가지고 있기 때문에 선언한 함수 안에서만 사용될 수 있어요.

### 지역과 지역 스코프

지역이란 **함수 몸체 내부**를 말하는 겁니다. 지역은 지역 스코프를 만들어요. 위에 코드에서 보시다 싶이 `var` 키워드로 선언한 `z`와 `var` 키워드로 선언한 `x`는 함수 몸체 내에서 지역 스코프를 갖는 지역 변수 입니다. 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효합니다. 그래서 `inner` 함수 내에서도 `z`를 참조 할 수 있는거에요. `outer` 함수 내에 `inner` 함수가 선언되었으니까요. 하지만 `z`는 함수 바깥쪽인 전역에선 참조할 수 없죠?
지역 스코프를 가지고 있기 때문입니다.

그런데, 전역에서 선언된 `x`가 있고, `inner` 함수 내에서 선언된 `x`가 있는데 자바스크립트는 어떻게 `inner` 함수에 있는 `x`를 참조하는 걸까요? 전역에서 선언된 `x`가 먼저 선언되어 있는데요.

자바스크립트 엔진이 스코프 체인을 통해 참조할 변수를 검색했기 때문인데, 스코프 체인에 대해서 알아볼게요.

## 스코프 체인

함수는 전역에서 정의할 수도 있고 함수 몸체 내부에서도 정의할 수 있죠? 함수 몸체 내부에서 함수가 정의된 것을 함수의 중첩이라고 부릅니다. 위에 우리가 예시로 들었던 `outer` 함수 내에 `inner` 함수를 정의한걸 함수의 중첩이라고 볼수 있겠죠?

`inner` 함수를 중첩함수 라고 부르고, 중첩 함수를 포함하는 `outer` 함수를 외부 함수라고 부릅니다.

함수는 중첩될 수 있으니 함수의 지역 스코프도 중첩될 수 있겠죠? 이는 **스코프가 함수 중첩에 의해 계층적 구조를 갖는다** 라는 의미가 돼요.

외부 함수의 지역 스코프를 중첩 함수의 상위 스코프라고 부릅니다. `outer` 함수의 상위 스코프는 전역 스코프일거고 `inner` 함수의 상위 스코프는 `outer` 함수 이겠죠? 이렇게 모든 스코프는 하나의 계층적 구조로 연결되고 이걸 **스코프 체인** 이라고 부릅니다.

**변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하며 상위스코프 방향으로 이동하며 선언된 함수를 검색 합니다**. 이 문장을 봤을 때 확실히 이해가 가지 않으신가요? 왜 전역변수 `x` 가 있는데 `inner` 함수에서 `x`를 선언하고 `console.log(x)`를 했을 때, 전역변수 `x`의 값이 아닌 `inner` 함수에서 선언된 `x`의 값을 보여줬는지요.

자바스크립트 엔진이 `console.log(x)` 가 읽힌 시점에서 `inner` 함수내의 스코프부터 읽어 올라가기 때문에 `inner` 함수 내에 이미 `x` 가 존재하고 있으니 그 값을 보여주게 된겁니다.

스코프 체인은 물리적인 실체로 존재하는데. 자바스크립트 엔진은 코드를 실행하기에 앞서서 위에 설명한 것과 유사한 자료구조인 **렉시컬 환경** 을 실제로 생성합니다. 변수 선언이 실행되면 변수 식별자가 이 자료구조에 키로 등록되고 변수 할당이 일어나면 이 자료구조의 변수 식별자에 해당하는 값을 변경합니다. 그래서 **렉시컬 환경**이 뭘까요?

### 렉시컬 환경

스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것입니다. 전역 렉시컬 환경은 코드가 로드되면 곧바로 생성되고 함수의 렉시컬 환경은 함수가 호출되면 곧바로 생성됩니다.

### 스코프 체인에 의한 변수 검색

```js
var x = "global x";
var y = "global y";

function outer() {
  var z = `outer's local z`;

  console.log(x); // global x
  console.log(y); // global y
  console.log(z); // outer's local z

  function inner() {
    var x = `inner's local x`;

    console.log(x); // inner's local x;
    console.log(y); // global y
    console.log(z); // outer's local z
  }
  inner();
}

outer();

console.log(x); // global x;
console.log(z); //ReferenceError : z is not defined
```

이 코드를 다시한번 봐볼게요. 이걸 다시 한번 자세하게 보면 자바스크립트 엔진이 스코프 체인을 통해 어떻게 변수를 찾아내는지 알 수 있습니다.

앞에서 설명했다 싶이, 스코프 체인은 단방향으로 연결되어 있어요. 하위 스코프에서 상위스코프로 올라가는 식으로 연결되어 있습니다.

`inner` 함수에서 `console.log(x)`를 하고 있죠. 이 때, 자바스크립트 엔진은 `inner` 함수 내에 선언된 `x`가 존재하는지 아닌지 부터 검색을 합니다. `inner` 함수는 `x`를 선언해서 가지고 있죠? 따라서 스코프 체인은 검색된 변수를 참조하고 검색을 종료합니다.

그 뒤 라인에 `console.log(y)`가 있습니다. 위에 설명했다 싶이, 스코프체인은 `inner`함수 내부부터 변수 검색을 시작하게 돼요. 하지만 `inner` 함수에는 선언된 `y`가 없으니 상위 스코프인 `outer` 함수 내에 `y`가 존재하는지를 검색합니다. 하지만 선언된 `y`가 없으니 `outer` 함수의 스코프를 빠져나가 전역 스코프를 확인하여 선언된 `y`값을 참조합니다.

`z`도 동일한 방식으로 작동해요. `inner` 함수에 선언된 `z`는 없고 `outer` 함수내에서 존재하니 `inner`함수의 스코프를 빠져나가 `outer` 함수 스코프 내에 존재하는 `z`를 참조합니다.

상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없어요.

### 스코프 체인에 의한 함수 검색

다음 예제를 한번 같이 봐볼게요,

```js
function foo() {
  console.log("global function foo");
}

function bar() {
  function foo() {
    console.log("local function foo");
  }

  foo();
}

bar();
```

앞에 우리가 함수를 공부할 때 봤듯이, 함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성됩니다. 그리고 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 선언하고 생성된 함수 객체를 생성해요.

결과는 똑같습니다 위에 장황하게 설명한 변수 스코프랑 똑같아요 결과는 `local function foo`가 개발자 도구에 찍힐 것입니다.

그러니 스코프는 **식별자를 검색하는 규칙** 이라고 보는게 좋아요.

## 함수 레벨 스코프

지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만든다고 했습니다. 이는 **코드 블럭이 아닌 함수에 의해서만 지역 스코프가 생성된다** 라는 의미에요.

대부분의 프로그래밍 언어는 함수 몸체만이 아니라 모든 코드 블럭(if, for, while, try/catch) 이 지역 스코프를 만드는데 이걸 **블럭 레벨 스코프** 라고 불러요. 하지만 **var 키워드로 선언된 변수는 오로지 함수의 코드블럭 만을 지역스코프로 인정**합니다.

이런 특징을 함수레벨 스코프라고 불러요.

```js
var x = 1;

if (true) {
  var x = 10;
}

console.log(x); // 10
```

전역변수 `x`를 `var` 키워드를 통해 선언하고, `if`문 내에서도 변수 `x`가 선언되었습니다. 이 때, `if`문 코드 블럭 내에서의 선언된 `x` 변수는 전역 변수에요. `var` 키워드로 선언된 변수는 함수 레벨 스코프만 인정하기 때문에 함수 밖에서 `var` 키워드로 선언된 변수는 코드 블럭 내에서 선언되었다 하더라도 모두 전역 변수입니다. 그래서 `x`가 중복 선언이 된거고 전역 변수의 값이 재할당 된겁니다. 다른 예제를 한번 볼게요.

```js
var i = 10;
for (var i = 0; i < 5; i++) {
  console.log(i);
}

console.log(i);
```

위의 전역 변수 `i`도 값이 변경되어 0으로 재할당되고 `for`문이 돌았을거에요. 블럭 레벨 스코프를 지원하는 프로그래밍 언어에서는 for 문에서 반복을 위해 선언된 i 변수가 지역 변수이기 때문에 이런 문제가 발생하지 않아요. ES6 부터는 `let`, `const`가 블럭 레벨 스코프를 지원하기 때문에 모던 자바스크립트에서는 `var`를 사용하지 않는 이유도 이겁니다.

## 렉시컬 스코프

다음 예제의 실행 결과를 한번 예측해볼까요?

```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo();
bar();
```

위 예제의 실행 결과는 `bar` 함수의 상위 스코프가 무엇인지에 따라 결정됩니다, 두가지 패턴을 예측할 수 있어요.

1. 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정
2. 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정

첫번째 방식으로 함수 상위 스코프를 결정한다면 `bar` 함수의 상위 스코프는 `foo` 함수의 지역 스코프와 전역 스코프 일것입니다.

두번째 방식으로 함수 상위 스코프로 결정한다면 `bar` 함수의 상위 스코프는 전역 스코프 일거에요.

첫번째 방식은 동적 스코프라고 하는데, 함수를 정의하는 시점에는 함수가 어디서 호출될지 알 수 없습니다. 따라서 함수가 호출되는 시점에 동적으로 상위 스코프를 결정해야 하기 때문에 동적 스코프 라고 부릅니다.

두번째 방식은 렉시컬 스코프, 또는 정적 스코프라고 하는데. 동적 스코프 방식처럼 상위 스코프가 동적으로 변하지 않고 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정되기 때문에 정적 스코프라고 불러요. 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따릅니다.

**자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위 스코프를 결정하겠죠? 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않아요. 즉, 함수의 상위 스코프는 언제나 자신이 정의된 스코프** 입니다.

이러처럼 함수의 상위 스코프는 함수 정의가 실행될 때, 정적으로 결정됩니다. 함수 정의가 실행되어 생성된 함수 객체는 이렇게 결정된 상위 스코프를 기억합니다. 함수가 호출될 때마다 함수의 상위 스코프를 참조할 필요가 있기 때문입니다.

그럼 이제 위 코드가 어떻게 동작될지 알 수 있을거 같아요.
`bar` 함수는 전역에서 정의된 함수입니다. 함수 선언문으로 정의된 `bar` 함수는 전역 코드가 실행되기 전에 먼저 평가되어 함수 객체를 생성하고 `bar` 함수 객체는 자신이 정의된 스코프, 즉 전역 스코프를 기억합니다. 그래서 자기가 어디서 호출이 되던 자기가 정의된 스코프 즉, `전역 스코프`를 상위 스코프로 사용을 해요.
그렇기 때문에 위 예제를 실행하면 전역 변수 `x` 값 1을 두번 호출합니다.
