# let, const 키워드와 블록 레벨 스코프

ES5 까지 변수를 선언할 수 있는 유일한 방법은 `var` 키워드를 사용하는 것이였어요. `var`키워드로 선언된 변수는 다음과 같은 특징이 있는데. 다른 언어와는 구별되는 독특한 특징으로, 주의를 기울이지 않으면 심각한 문제가 발생합니다.

## var 키워드로 선언한 변수의 문제점

### 변수의 중복 선언 허용

```js
var x = 1;
var y = 1;

var x = 100;
var y;

console.log(x);
console.log(y);
```

위 예제의 `var` 키워드로 선언한 `x`와 `y`는 중복 선언이 되었어요. `var` 키워드로 선ㅁ언한 변수를 중복 선언하면 초기화문 유무에 따라 다르게 동작하는데, 초기화 문이 있는 경우 `var` 키워드가 없는 것처럼 동작하고 초기화문이 없는 변수 선언문은 무시됩니다. 이때 에러가 발생하지도 않아요.

위 예제처럼 만약 동일한 변수가 이미 선언되어 있는 것을 모르고 변수를 중복 선언하면서 까지 값을 할당해버리면 먼저 선언된 변수 값이 변경되어 버립니다.

### 함수 레벨 스코프

우리 스코프를 공부하면서 봤었죠? `var` 키워드로 선언한 변수는 오로지 코드 블럭만을 지역 스코프로 인정합니다. 따라서 함수 외부에서 `var` 키워드로 선언한 변수는 코드 블럭 내에서 선언해도 모두 전역 변수가 되어버려요. 함수 레벨 스코프는 전역 변수를 남발할 가능성을 높이고 이로 인해 의도치 않게 전역 변수가 중복 선언되는 경우도 발생합니다.

### 변수 호이스팅

`var` 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작합니다. 즉, 변수 호이스팅에 의해 `var` 키워드로 선언한 변수는 변수 선언문 이전에 참조 할 수 있어요, 단 할당문 이전에 변수를 참조하면 `undefined`를 반환합니다.

변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생시키지는 않지만 프로그램의 흐름상 맞지도 않고 가독성이 떨어지며 오류를 발생시킬 여지를 남깁니다.

## let 키워드

앞에서 살펴본 var 키워드의 단점을 보완하기 위해 ES6 에서는새로운 변수 선언 키워드인 `let`과 `const`를 도입했습니다. `var`와 `let`이 어떻게 다른지부터 살펴볼게요.

### 변수 중복 선언 금지

`let` 키워드로 이름이 같은 변수를 중복 선언하면 문법 에러가 발생합니다. `var` 키워드에서는 전혀 오류가 발생하지 않았었죠?
변수를 중복 선언을 할 수 없게 막아줍니다. 그럼 이전에 우리가 문제점으로 지적했던 문제가 발생하지 않을거에요.

### 블록 레벨 스코프

`var` 키워드로 선언한 변수는 함수의 코드블럭만을 지역 스코프로 인정하지만, `let` 키워드로 선언한 변수는 모든 코드블럭을 지역 스코프로 인정하는 블록 레벨 스코프를 가져요.

```js
let foo = 1;

{
  let foo = 2;
  let bar = 3;
}

console.log(foo);
console.log(bar);
```

위 코드를 보시면 foo가 코드블럭 내에도 있고 코드블럭 밖에도 존재합니다. 두개는 별개의 변수에요. 코드블럭 내에 있는 변수 `foo`와 `bar`는 지역 변수입니다. 따라서 전역에서는 `bar`를 참조할 수 없어요.

### 변수 호이스팅

var 키워드로 선언한 변수와 달리 let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것 처럼 동작합니다. 하지 않는다는 것이 아니라 **"발생하지 않는 것 처럼 동작"** 이에요. 호이스팅이 일어나긴 합니다.

이전에 변수에서 제가 따로 정리했듯이, `let` 과 `const` 같은 경우에는 변수의 "선언 단계"와 "초기화 단계"가 분리되어 진행돼요. 런타임 이전에 자바스크립트에 의해 암묵적으로 선언 단계가 먼저 실행은 되지만, 변수 선언문에 도달했을 때, 초기화가 실행돼요.
그래서 초기화 단계가 실행되기 전에 변수를 참조하려 하면 참조 에러가 발생합니다. 이 구간을 일시적 사각지대(TDZ) 라고 불러요.

### 전역 객체와 let

var 키워드로 선언한 전역 변수와 전역 함수, 그리고 선언하지 않은 변수에 값을 할당한 암묵적 전역은 전역 객체 window의 프로퍼티가 됩니다. 하지만 let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니에요. let 전역 변수는 보이지 않는 개념적인 블록 내에 존재합니다.

## const 키워드

const 키워드는 상수를 선언하기 위해 사용합니다. 하지만 반드시 상수만을 위해 사용하지는 않아요.

### 선언과 초기화

**const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화 해야 합니다** 그렇지 않으면 문법 에러가 발생해요.

### 재할당 금지

`const` 키워드로 선언한 변수는 재할당이 금지됩니다.

### 상수

const 로 선언한 변수에 원시 값을 할당한 경우 변수 값을 변경할 수 없습니다. 변경 불가능한 값이므로 재할당 없이 값을 변경할 수 있는 방법이 없어요.

변수의 상대 개념인 "상수"는 재할당이 금지된 변수를 말합니다. 상수는 상태 유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용해야 해요.

const 키워드로 선언된 변수에 원시 값을 할당한 경우 원시 값은 변경할 수 없는 값이고 const 키워드에 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없습니다. 일반적으로 상수의 이름은 대문자로 선언해 상수임을 명확히 나타내고, 여러 단어로 이루어진 경우에는 언더스코어로 구분해서 스네이크 케이스로 표현하는 것이 일반적입니다.

### const 키워드와 객체

const 키워드로 선언한 변수에 원시 값을 할당한 경우 값을 변경할 수 없지만, const 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있습니다.

const 는 재할당을 금지할 뿐, 불변을 의미하지는 않습니다.

## var vs let vs const

변수 선언에는 기본적으로 const를 사용하고, let 은 재할당이 필요한 경우에 한정해 사용하는 것이 좋습니다. const 키워드를 사용하면 의도치 않은 재할당을 방지하기 때문에 좀 더 안전합니다.

- ES6를 사용한다면 var 키워드를 사용하지 않는다
- 재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.
- 변경이 발생하지 않고 읽기 전용으로 사용하는 원시 값과 객체에는 const 키워드를 사용한다 const는 재할당을 금지하므로 var, let 키워드보다 안전하다.
