# 생성자 함수에 의한 객체 생성

"객체 리터럴"을 공부했을 때, 객체 리터럴에 의한 객체 생성 방식을 살펴본 적이 있습니다. 이게 가장 일반적이고 간단한 객체 생성 방식인데, 객체는 객체 리터럴 이외에도 다양한 방법으로 생성이 가능합니다.

## Object 생성자 함수

`new` 연산자와 함께 `Object` 생성자 함수를 호출하면 빈 객체를 생성해 반환해 줍니다. 빈 객체를 생성 후 프로퍼티 또는 메서드를 추가해 객체 완성이 가능합니다.

```js
const person = new Object();

person.name = "Hannah Jeong";
person.sayHello = function () {
  console.log(`Hi! my name is + ${this.name}`);
};

console.log(person); // {name : "Hannah Jeong", sayHello : f}
person.sayHello(); // Hi! My name is Hannah Jeong
```

생성자 함수란 `new` 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수입니다. 생성자 함수에 의해 생성된 객체를 인스턴스라 합니다.

자바스크립트는 `Object` 생성자 함수 이외에도 `String, Number, Boolean, Function, Array, Date, RegExp, Promise` 등의 빌트인 생성자 함수를 제공합니다.

반드시 `Object` 생성자 함수를 사용해 빈 객체를 생성해야 하는 것은 아니다. 객체를 생성하는 방법은 객체 리터럴을 사용하는 것이 더 간편합니다.

## 생성자 함수

### 객체 리터럴에 의한 객체 생성 방식의 문제점

객체 리터럴에 의한 객체 생성 방식은 직관적이고 간편하지만 단 하나의 객체만 생성합니다. 따라서 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우엔 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적입니다.

### 생성자 함수에 의한 객체 생성 방식의 장점

생성자 함수에 의한 객체 생성 방식은 마치 객체(인스턴스) 를 생성하기 위한 템플릿처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있습니다.

```js
function Circle(radius) {
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

const circle1 = new Circle(5);
const circle2 = new Circle(10);
```

생성자 함수는 이름 그대로 객체를 생성하는 함수입니다. **new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작**합니다. 만약 new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작합니다.

### 생성자 함수의 인스턴스 생성 과정

생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 탬플릿으로 인스턴스를 생성하고 초기화 하는것입니다.

```js
function Circle(radius) {
  // 1. 암묵적으로 인스턴스가 생성, this에 바인딩
  // 2. this에 바인딩되어 있는 인스턴스를 초기화
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
  // 3. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환
}

// 인스턴스 생성. Circle 생성자 함수는 암묵적으로 this를 반환
const circle1 = new Circle(5);
const circle2 = new Circle(10);
```

생성자 함수 내부의 코드를 살펴보면 `this`에 프로퍼티를 추가하고 필요에 따라 전달된 인수를 프로퍼티의 초기값으로 할당하여 인스턴스를 초기화합니다. 자바스킯트 엔진은 암묵적인 처리를 통해 인스턴스를 생성하고 반환하는데, new 연산자와 함께 생성자 함수를 호출하면 자바스크립트 엔진은 아래와 같은 과정으로 인스턴스를 생성, 초기화, 반환한다.

#### 1. 인스턴스 생성과 this 바인딩

암무적으로 빈 객체가 생성된다. 이 빈 객체가 바로 생성자 함수가 생성한 인스턴스 입니다. 암묵적으로 생성된 빈 객체, 즉 인스턴스는 this에 바인딩 됩니다. 생성자 함수 내부의 this가 생성자 함수가 생성할 인스턴스를 가리키는 이유가 이겁니다.

> **바인딩** <br>
> 바인딩이란 식별자와 값을 연결하는 과정을 의미합니다. 예를 들어, 변수 선언은 변수 이름과 확보된 메모리 공간의 주소를 바인딩 하는 것입니다. this 바인딩은 this와 this가 가르킬 객체를 바인딩 하는 것입니다.

#### 2. 인스턴스 초기화

생성자 함수에 기술되어 있는 코드가 한 줄씩 실행되어 this에 바인딩되어 있는 인스턴스를 초기화합니다. this에 바인딩 되어 있는 인스턴스에 프로퍼티나 메서드를 추가하고, 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당합니다.

#### 3. 인스턴스 반환

생성자 함수 내부에서 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this를 암묵적으로 반환합니다. 만약 this가 아닌 다른 객체를 명시적으로 반환하면 this가 반환되지 못하고 return 문에 명시한 객체가 반환됩니다.

### 내부 메서드 [[Call]] 과 [[Construct]]

함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있습니다.

생성자 함수로 호출한다는 것은 `new 연산자와 함께 호출` 하여 객체를 생성하는 것을 의미

함수는 객체이므로 일반 객체와 동일하게 동작할 수 있습니다. 함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드를 모두 가지고 있기 때문입니다.

```js
function foo() {}

foo.prop = 10;

foo.method = function () {
  console.log(this.prop);
};

foo.method();
```

함수는 객체이지만 일반 객체랑은 다릅니다. 일반 객체는 호출할 수 없지만 함수는 호출할 수 있습니다. 함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드는 물론, 함수로서 동작하기 위해 함수 객체만을 위한 [[Environment]], [[FormalParameters]] 등의 내부 슬롯과, [[Call]], [[Construct]] 같은 내부 메서드를 추가를 가지고 있습니다.

함수가 일반 함수로서 호출되면 함수 객체의 내부 메서드 [[Call]]이 호출되고, new 연산자와 함께 생성자 함수로서 호출되면 [[Construct]]가 호출됩니다.

내부 메서드 [[Call]] 을 가지고 있는 함수 객체를 `callable`이라 하고, 내부 메서드 [[Construct]]를 같는 함수 객체를 constructor, [[Construct]]를 갖지 않는 함수 객체를 non-constructor 라고 부릅니다.

호출할 수 없는 객체는 함수 객체가 아니므로 함수로서 기능하는 객체, 즉 함수 객체는 반드시 `callable` 이여야 합니다.

하지만, 모든 함수가 [[Construct]]를 갖는건 아닙니다.

### constructor 와 non-constructor의 구분

- constructor : 함수 선언문, 함수 표현식, 클래스
- non-constructor : 메서드(ES6 메서드 축약 표현), 화살표 함수

함수를 프로퍼티 값으로 사용하면 일반적으로 메서드로 통칭하는데, ECMAScript 사양에서 메서드란 ES6의 메서드 축약 표현만을 의미합니다. 함수가 어디에 할당되어 있는지에 따라 메서드인지를 판단하는 것이 아닌 함수 정의 방식에 따라 구분됩니다.

함수를 일반 함수로서 호출되면 내부 메서드 [[Call]]이 호출되고 new 연산자와 함께 생성자 함수로서 호출하면 [[Construct]]가 호출된다고 설명했었죠? `non-constructor` 인 함수 객체를 생성자 함수로서 호출하면 에러가 발생해버립니다.

### new 연산자

일반 함수와 생성자 함수에 특별한 형식적 차이는 없고, new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작합니다. 단, new 연산자와 함께 호출하는 함수는 `non-constructor`가 아니여야 합니다.

### new.target

생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위해 파스칼 케이스 컨벤션을 사용한다 하더라도 실수는 언제나 발생합니다. 이런 위험성을 회피하기 위해 ES6 에서는 new.target 을 지원합니다.

`new.target`은 this와 유사하게 constructor 인 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용되며, 메타 프로퍼티라고 부릅니다.

**new 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 new.target 은 함수 자신을 가리킵니다. new 연산자 없이 일반 함수로서 호출된 함수 내부의 new.target은 undefined** 입니다.
